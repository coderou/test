1.复习
  分页器思路:
    1.实现最基本的最理想的情况
    2.考虑边界值,靠左,靠右,如果小于2,直接等于2,如果大于最大值-1,直接等于
    3.考虑极端情况,小于7个,等于1个的时候
    4.middle按钮动态显示
    5.判断情况动态显示... 
    6.按钮高亮,点击当前页面+1,极限值判断,
    7.优化:频繁点击防抖,设置第一次生效,最后一次生效
  其他:v-if和v-for不能同时使用,v-for优先级更高,但是配合v-if会造成不必要的性能浪费,解决办法是在外面包v-if
  或者改变逻辑
2.写一个获取元素到文档边缘距离的函数
3.如果一上来就要初始化使用的话,最好就会初始化一个数据
  #store/modules/detail.js
  {
    ...
    skuImgList:[],
  }
4.放大镜和vuex异步拿数据的解决办法等
  #store/modules/detail.js
  {
    // 既然始终拿不到 skuImageList[0].imgUrl,就直接初始化吧,
    export const state={
      goodsDetail:{
        skuInfo:{
          skuImgeList:[{imgUrl:''}],
        },
      },
    };

    export const getters={
      skuImageList(state) {
        return state.goodsDetail.skuInfo.skuImageList;
      },
    }
  }
  #views/Detail/Detail.vue
  {
    <template>
      <Zoom />
      <ImageList :skuImageList="skuInfo.skuImageList" />
    </template>
  }
  #views/Detail/Zoom/Zoom.vue
  {
    <template>
      <!-- <img :src="skuImageList[0].imgUrl" /> -->
      <img :src="imgUrl" />

      <div class="big">
        <!-- <img ref="bigImg" :src="skuImageList[0].imgUrl" /> -->
        <img ref="bigImg" :src="bigUrl" />
      </div>
    </template>
    <script>
      import {mapGetters} from 'vuex';
      import throttle from 'lodash/throttle';
      export default{
        data() {
          return {
            // 可以不初始化么?不行,因为添加的数据不是响应式的!
            imgUrl: '',
            bigUrl: '',
          };
        },
        computed: {
          ...mapGetters(['skuImageList']),
        },
        methods: {
          show: throttle(function (e) {
            const { mask, bigImg } = this.$refs;
            /*
              offsetX:e事件距离该元素边缘的位置
            */
            const maskY = e.offsetY - mask.clientWidth / 2;
            const maskX = e.offsetX - mask.clientHeight / 2;
            // 滑块位置
            const maskPosition = {
              x: maskX,
              y: maskY,
            };
            if (maskPosition.x <= 0) maskPosition.x = 0;
            if (maskPosition.y <= 0) maskPosition.y = 0;
            if (maskPosition.x >= 200)maskPosition.x = 200;
            if (maskPosition.y >= 200)maskPosition.y = 200;
            // console.log(maskPosition);
            mask.style.left = `${maskPosition.x}px`;
            mask.style.top = `${maskPosition.y}px`;
            // 大图位置
            const bigImgPosition = {
              x: -maskX * 2,
              y: -maskY * 2,
            };
            bigImg.style.left = `${bigImgPosition.x}px`;
            bigImg.style.top = `${bigImgPosition.y}px`;
          }, 10, {}),
        },
        mounted() {
          this.$bus.$on('receive_imgs', ({ imgUrl, bigUrl }) => {
            this.imgUrl = imgUrl;
            this.bigUrl = bigUrl;
          });
        },
      }
    </script>
  }
  #views/Detail/ImageList/ImageList.vue
  {
    <template>
      <div class="swiper-wrapper">
        <div
          v-for="(img, index) in skuImageList"
          :key="img.id"
          class="swiper-slide"
        >
          <img
            :class="{ active: currentIndex === index }"
            :src="img.imgUrl"
            :alt="img.imgName"
            @click="setCurrentIndex(index)"
          />
        </div>
      </div>
    </template>
    <script>
      import Swiper from 'swiper';
      export default{
        props: ['skuImageList'],
        data() {
          return {
            currentIndex: 0,
          };
        },
        watch: {
          // 监视获取到了数据
          skuImageList() {
            this.setCurrentIndex(0);// 数据拿到,触发一次emit,将数据传递给Zoom
            this.$nextTick(() => {
              /* eslint-disable-next-line */
              this.swiper = new Swiper(this.$refs.swiper, {
                cssMode: true,
                navigation: {
                  nextEl: ".swiper-button-next",
                  prevEl: ".swiper-button-prev",
                },
                slidesPerView: 5, // 每页显示图片数量
                slidesPerGroup: 5, // 每次轮播滑动的图片数量
              });
            });
          },
        },
        methods: {
          setCurrentIndex(index) {
            this.currentIndex = index;
            this.$bus.$emit('receive_imgs', {
              imgUrl: this.skuImageList[index].imgUrl,
              bigUrl: this.skuImageList[index.imgUrl], // 将来大图不一样,就要换一个容器
            });
          },
        },
      }
    </script>
  }
5.邪道速通:如果遇到页面渲染数据的时候,vuex还没有拿到数据或者数据还没有回来,方法就是用getters,直接映射,然后state中定义默认数据即可
6.fixBug:ImageList.vue 的style
7.关于a标签,只要是和页面跳转相关的,都用a标签,只要不是,都不要
8.创建一个InputNumber组件
  #views/Detail/InputNumber/InputNumber.vue
  {
    <template>
      ....
    </template>
    <script>
      export default{

      }
    </script>
  }
9.$listeners  是给组件绑定的一些自定义事件的函数,如果
  {
    v-model 指令原理:
    给元素绑定value属性和input事件
    给组件设置v-model
      组件得到一个value属性
        和一个自定义事件input
    之前的elementUI可以实现数据同步内部也同样用了类似的处理方式
  }
10.实现商品详情右边属性选择&商品数量选择
  #views/Detail/Detail.vue
  {
    <template>
      <dd
        v-for="spuSaleAttrValue in spuSaleAttr.spuSaleAttrValueList"
        :class="{
          active: spuSaleAttrValue.isChecked === '1',
        }"
        :key="spuSaleAttrValue.id"
        @click="
          setChecked(
            spuSaleAttrValue,
            spuSaleAttr.spuSaleAttrValueList,
          )
        "
      >
        {{ spuSaleAttrValue.saleAttrValueName }}
      </dd>
      <div class="cartWrap">
        <!--
          v-model 指令原理：
            给元素绑定value属性和input事件
            给组件设置v-model
              组件得到一个value属性
                  和一个自定义事件input
          -->
        <InputNumber v-model="num" />
        <div class="add">
          <a href="javascript:">加入购物车</a>
        </div>
      </div>
    </template>
    <script>
      import InputNumber from './InputNumber/InputNumber.vue';
      export default{
        data(){
          return {
            num:2,// 默认显示数量
          };
        },
        components:{
          InputNumber,
        },
        methods:{
          // 这里是利用了vue的响应式实现的商品属性选择,react中就真的需要遍历然后逐个修改了
          setChecked(saleAttrValue, saleAttrValueList) {
            // 下面是将所有的改为不选中
            // eslint-disable-next-line no-return-assign
            saleAttrValueList.forEach((value) => (value.isChecked = '0'));
            // 将点击的改为选中
            saleAttrValue.isChecked = '1';
          },
        },
      }
    </script>
  }
  #views/Detail/InputNumber/InputNumber.vue
  {
    <template>
      <div class="controls">
        <input
          autocomplete="off"
          class="itxt"
          :value="newValue"
          @blur="setNewVal"
          @keyup.enter="setNewVal"
        />
        <span
          class="plus"
          @click="newValue++"
          :disabled="newValue >= max"
          :class="{ disabled: newValue >= max }"
          >+</span
        >
        <span
          class="mins"
          @click="newValue--"
          :disabled="newValue <= min"
          :class="{ disabled: newValue <= min }"
          >-</span
        >
      </div>
    </template>
    <script>
      export default {
        name: 'InputNumber',
        props: {
          max: {
            type: Number,
            default: 1000,
          },
          min: {
            type: Number,
            default: 1,
          },
          value: {
            type: Number,
            default: 1,
          },
        },
        data() {
          return {
            newValue: this.value,
          };
        },
        mounted() {
          console.log(this);
        },
        watch: {
          newValue(newVal, oldVal) {
            /*
              1. 如果值是非法的：10abc
                使用oldVal

              2. 如果值小于 min
                就等于min

              3. 如果值大于 max
                就等于max

              4. 如果值合法的
                就使用newVal
            */
            // console.log(newVal, oldVal);
            if (newVal === oldVal) return;

            newVal = Number(newVal);
            let finalVal = newVal;

            // 1. 如果值是非法的：10abc
            if (Number.isNaN(newVal)) {
              finalVal = oldVal;
              // this.$emit("input", this.newValue);
              // this.$listeners.input(this.newValue);
              // return;
            }

            const { min, max } = this;

            // 2. 如果值小于 min
            if (newVal < min) {
              finalVal = min;
              // this.$emit("input", this.newValue);
              // return
            }

            // 3. 如果值大于 max
            if (newVal > max) {
              finalVal = max;
              // this.$emit("input", this.newValue);
              // return
            }

            this.newValue = finalVal;
            this.$emit('input', finalVal);
          },
        },
        methods: {
          setNewVal(e) {
            const newVal = e.target.value;
            this.newValue = newVal;
          },
        },
      };
    </script>
  }
11.InputNumber为什么要封装为一个组件?
  1.封装组件目的主要是:
    1.复用(代码重复,封装)
    2.解耦(代码过多,封装)
  2.并且方便以后维护
  3.如果是当前组件使用的,那么直接封装在内部即可
  4.并且能快速定位到到底那个组件出现问题
12.下午:加入购物车
  1.事件总线使用注意点:2个通信的组件必须加载好
  2.前端主要负责的就是数据显示,本质上用户适用App是在和后台进行交互
  3.tip:添加购物车和修改购物车数量都是同一个接口
13.添加购物车
  #api/shopcart.js
  {
    import request from './request';
    const PREFIX_URL = '/cart';
    // 获取购物车列表
    export const reqGetCartList = () =>
      request({
        method: 'GET',
        url: `${PREFIX_URL}cartList`,
      });
    // 添加购物车
    export const reqAddCartList = (skuId, skuNum) =>
      request({
        method: 'GET',
        url: `${PREFIX_URL}addToCart/${skuId}/${skuNum}`,
      });
    // 更新商品选中状态
    export const reqUpdateCartList = (skuId, isChecked) =>
      request({
        // 这里是修改,理论上应该是POST
        method: 'GET',
        url: `${PREFIX_URL}checkCart/${skuId}/${isChecked}`,
      });
    // 删除商品
    export const reqDeleteCartList = (skuId) =>
      request({
        // 这里是修改,理论上应该是POST
        method: 'DELETE',
        url: `${PREFIX_URL}deleteCart/${skuId}`,
      });
  }
  #store/modules/shopcart.js
  {
    import {
      reqGetCartList,
      reqAddCartList,
      // reqUpdateCartList,
      // reqDeleteCartList,
    } from '@/api/shopcart';
    export const state = {
      cartList: [],
    };
    export const getters = {};
    export const actions = {
      getCartList({ commit }) {
        return reqGetCartList()
          .then((cartList) => {
            commit('GET_CART_LIST', cartList);
          })
          .catch((message) => {
            console.log(message);
          });
      },

      addCartList({ commit }, { skuId, skuNum }) {
        // reqGetCartList函数返回一个promise,默认成功promise
        // 只有函数内部报错了,会返回失败的promise
        // 或者是内部返回一个promise,那么整个函数返回的promise就是返回的这个promise,而不是默认的
        return reqAddCartList(skuId, skuNum).then(() => {
          // 外面是一个promise,里面也是一个promise,
          // 如果不设置返回值,默认返回一个成功的promise,如果返回的是新promise,
          // 外面的promise由内部promise决定
          // tip:将函数返回出去,让外面判断这个成功状态
          commit('ADD_CART_LIST');
          // .catch((message) => { //如果不写,就会在调用action的地方进行处理
          //   console.log(message);
          // })
          // .then(() => {}) // 成功/失败都会触发,只要是没有报错,没有返回promise,都会触发
        });
      },
    };
    export const mutations = {
      GET_CART_LIST(state, cartList) {
        state.cartList = cartList;
      },
      ADD_CART_LIST() {},
    };
  }
  #store/modules/index.js
  {
    import * as shopcart from './shopcart ';
    export default{
      shopcart,
    }
  }
  #views/Detail/Detail.vue
  tip:
    调用action函数返回值是一个promise对象,如果内部是发送请求,可以将请求return出去,在外面进行处理
  面试:
    怎么等添加成功后,在这里处理成功\失败的情况? 
    在内部将发送请求的promise返回出来
  {
    <template>
      <InputNumber v-model="num" />
      <div class="add" @click="addCart">
        <a href="javascript:">加入购物车</a>
      </div>
    </template>
    <script>
      export default{
        methods:{
          ...mapActions(['addCartList']),
          async addCart() {
            // 1.发送请求,更新购物车数据
            /*
              tip:
                调用action函数返回值是一个promise对象
              面试:
                怎么等添加成功后,在这里处理成功\失败的情况? 
                在内部将发送请求的promise返回出来
            */
            // const res = await this.addCartList({ skuId: this.skuInfo.id, skuNum: this.num });
            // console.log(res) // 是一个promise对象,注意:acitons内部包含了2个promsie请求,外层是这里的,内层才是真正发送请求
            // this.addCartList({
            //   skuId: this.skuInfo.id,
            //   skuNum: this.num,
            // })
            //   // 请求成功==功能成功(因为设置了拦截器)
            //   .then(() => {})
            //   // 功能失败
            //   .catch((message) => {});

            try {
              await this.addCartList({
                skuId: this.skuInfo.id,
                skuNum: this.num,
              });
              // 2.请求成功,存储数据到sessionStorage中(会话存储)
              const { skuName, skuDesc, skuDefaultImg, price } = this.skuInfo;

              // #region
              /* 
              "spuSaleAttrList": [
                {
                  "id": 1,
                  "spuId": 1,
                  "baseSaleAttrId": 1,
                  "saleAttrName": "选择颜色",
                  "spuSaleAttrValueList": [
                    {
                      "id": 1,
                      "spuId": 1,
                      "baseSaleAttrId": 1,
                      "saleAttrValueName": "黑色",
                      "saleAttrName": "选择颜色",
                      "isChecked": "0"
                    },
                    …
                  ]
                },
              */
              // #endregion

              const saleAttrList = this.spuSaleAttrList.map((saleAttrValue) => ({
                // id
                id: saleAttrValue.id,
                // 销售属性名称
                saleAttrName: saleAttrValue.saleAttrName,
                // 销售属性选中你的值(其他值不变)
                saleAttrValueName: saleAttrValue.spuSaleAttrValueList.find(
                  (saleAttr) => saleAttr.isChecked === '1',
                ).saleAttrValueName,
              }));
              // 3.储存会话数据
              window.sessionStorage.setItem(
                'cart',
                JSON.stringify({
                  skuName,
                  skuDesc,
                  skuDefaultImg,
                  price,
                  saleAttrList,
                }),
              );
              // 4.跳转到添加购物车成功页面
              this.$router.history.push({
                path: '/addcartsuccess',
                query: {
                  skuNum: this.num,
                },
              });
            } catch (e) {
              console.error(e);
            }
          },
        },
      }
    </script>
  }
14.tip:鼠标移动到异步函数上面,可以将其转换为异步函数async
15.tip:引入模块的时候,路径名后面不能多空格,否则报错This relative module was not found
16.