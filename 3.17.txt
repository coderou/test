1.ToB:一种业务模式,B指的是Business,即企业
  基本概念:
    ToB就是在企业业务中，以企业作为服务主体为企业客户提供平台、产品或服务并赚取利润的业务模式，我们也可以把它称之为企业服务。
  常见的ToB业务模式:
    B2C平台:京东,美团,天猫等
    B2B平台:阿里巴巴
    提供咨询和解决方案产品:广告公司,企业培训服务,咨询管理服务
    提供原材料、生产设备及供应链服务:比如口罩生产商,比如生产设备等,或者叫ToF(Factory)
    传统产品经销分销模式:比如某耐克,某361等
    软件系统和SaaS产品:金蝶云,钉钉,企业微信
    提供代运营服务的公司:新媒体,外包
  总体分类:平台型业务\服务型业务\硬件形业务
  ToB到底解决的是企业的什么问题？
    ToB解决的核心问题就是如何提高企业效率和效益。
  亮点:
    过去时代的发展让很多“C”接受了互联网的革新，今后时代的发展也必将让很多“B”追赶上数字化的浪潮！
2.his系统:HIS英文全称 hospital information system，直译为中文就是医院信息系统
  HIS的主要功能按照数据流量、流向及处理过程分为临床诊疗、药品管理、经济管理、综合管理与统计分析、外部接口五部分。
  tip:
    一般来说，HIS的开发过程可以分为以下几个步骤：
    a.准备项目计划书
    b.软件及软件供应商、硬件及网络集成商和合作伙伴的选择
    c.系统的需求分析
    d.系统可行性分析与开发计划
    e.系统的设计：总体设计与各个部分的详细设计
    f.系统的实现：各部分系统的实现与整体系统的实现
    g.系统的整合与组装
    h.系统的测试
    i.用户培训
    j.系统的使用与维护
    k.系统的升级与更新
    而根据国家卫生部2002公布的《医院信息系统基本功能规范》规定医院信息系统开发应提供以下技术文档：
    总体设计报告
    需求分析说明书
    概要设计说明书
    详细设计说明书
    数据字典
    数据结构与流程
    测试报告
    操作使用说明书
    系统维护手册
3.ToC和ToB:
  1.和ToB的区别:
    https://zhuanlan.zhihu.com/p/30144769
  2.tob面对的是企业级用户,业务系统往往很复杂
    toc面对的是个人,业务针对某特定场景
    tob更加关注业务流程的正确性,toc更关注并发量,可用性
  3.tob的付费者和使用者往往不是同一批人,工作中心在于搞定付费者
    toc更多的放在打磨产品上,因为直接面相用户
  tip:这就是为什么ToC行业有那么多产品经理，而ToB行业却有那么多销售和售前。
  4.PoC（proof of concept）:针对客户场景的验证性测试
    tob往往是大单子,对应每个阶段的都需要验证,并且结果也不一定会成功,比如某某企业投资N亿做ERP失败
  5.项目周期
    ToB的项目周期很长，一般来说分为6个步骤：1）内部需求和立项；2）对供应商初步调查、筛选；3）制定采购指标；4）招标、评标；5）购买承诺；6）安装实施。可以看到实施只是6个步骤中最后的一个，前面的5个步骤都是销售和售前发挥的空间。
    相对来说，ToC根本没有项目实施的概念，只有产品开发周期。
  6.🍔技术地位
    正是因为以上的区别，ToB项目里甲方的业务往往比甲方的技术有发言权（除了业务复杂需要业务人员梳理外，业务往往能产出真金白银的实际销售额，而技术一般是个成本部门），同时乙方的销售往往比乙方的技术有发言权。总的来说，两边的技术算是难兄难弟，地位都不高。
    而ToC则很难说，比如B重技术、A重运营、T重产品，但不管怎么样，技术都是很有地位的。
  7.可复制性
    Tob往往不同企业需求大方向相同,细节千差万别,复制性低
    toc不说了,ccvv
  8.更新成本
    App几天就是一个小更新,APP有任何BUG或功能缺失，赶紧追加一个版本即可，更新成本非常低，所以适合快速迭代。
    而ToB往往部署在客户的私有环境，往往难以远程更新,一旦出现问题就需要派人去现场，更新成本较高,
    即:ToC可以快速迭代，小步前进；而ToB则必须求稳，减少不必要的版本更新。
  9.产品反馈链路
    ToC的好处就是可以及时听到用户的意见，并进行针对性调整。在有些定不下方向的场景，可以做A/B test来选择前进的方向。
    ToB的最终用户和产品开发人员之间，隔着决策者、销售、售前等多层关系,
      反馈往往很难及时传达到产品开发人员，甚至可能根本传达不到。在定不下方向的时候，也不存在A/B test，因为更新成本高，大客户也不允许自己被当做小白鼠。
  10.商业曲线,生命周期
    对于商业曲线来说，ToB企业相对平缓，一年很难有100%以上的增长。同样的，ToB企业也很难猝死，一旦获取企业用户，持续的运维费用和新项目的展开都可以提供源源不断的销售额。
    而ToC企业往往是暴涨暴跌式的，可能几个月就能吸引到一大波用户，可能没几个月又突然因为资金链断裂而倒闭。
    可以说，ToC企业如果三五年还没有发迹的迹象，基本可以gg了；而ToB企业，三五年可能还是个不够资格在圈子里说话的孩子。
  11.🍔竞争对手手与压力
    那么年轻人是不是全往ToC去好呢？显然也不是。
    ToC的饱和很快就要到来，或者说已经到来。ToC的竞争对手不仅仅是同行业的其他企业，还包括其他的ToC行业，因为大家最终竞争的是人的24个小时。
    比如一个人一天只有24小时，花了8小时睡觉，8小时工作，剩下8小时所有的ToC企业都在竞争。如果拿来看电视了，就不能愉快的购物了，如果用来玩游戏了，社交网就不够积极了。
    在这种论调下，节约时间的增效性软件相对会机会更多，比如打车软件和单车软件。
4.购物车
  tip:
    - 计算总结,已选择商品用的getters,因为用到了计算,使用数组方法为reduce
    - action中函数({commit,state})都有
  1.header.vue点击我的购物车跳转到购物车
  2.shopCart更新小计商品价格
  3.复习
    3.表单校验的handleSubmit:校验成功才会提交,如果不写handleSubmit,校验不成功就会提交
      tip:作用域插槽:一般不会主动使用,通常是使用被人的库使用到
    4.只要是表单项,都是v-model
    5.正则不建议自己写
    6.token和uuid都要携带上,token表示有没有登录过
    7.请求拦截器中添加token
    8.文件之间互相引用会提示死循环,但是实际上es6会自动修复
    9.互相引用是经常出现的,一般不会出现死循环,只有函数调用和setState才会
    10.开发开始
    11.拿到页面数据
    12.路由引入组件,配置路由
    13.irregular:不规则的,不合规的
    14.vue3废弃掉了过滤器,所有过滤器都可以用计算属性来做
    15.vue3源码:要更高的薪资?
  4.api/pai.js
5.自己设计一些组件
6.用了一项技术就记录下自己是如何使用的,便于分享
7.自己写一个表单校验插件
8.购物车代码:
  #components/Header/Header.vue
  {
    <router-link to="/shopcart">我的购物车</router-link>
  }
  #views/ShopCart/ShopCart.vue
  {
    <input :value="cart.skuNum"  />
    <span class="sum">{{ cart.skuNum * cart.skuPrice }}</span>
  }
  #router/routes.js
  {
    import Trade from "@/views/Trade";
    import Pay from "@/views/Pay";
    import PaySuccess from "@/views/PaySuccess";
    import Center from "@/views/Center";
    export default{
      {
        path: "/trade",
        name: "Trade",
        component: Trade,
      },
      {
        path: "/pay",
        name: "Pay",
        component: Pay,
      },
      {
        path: "/paysuccess",
        name: "PaySuccess",
        component: PaySuccess,
      },
      {
        path: "/center",
        name: "Center",
        component: Center,
      },
    }
  }
  #🤣🤣api/pay.js(cv的,没自己写)
  {
    import request from "./request";
    // 1.获取所有订单列表
    export const reqGetOrderList = (page, limit) =>
      request({
        method: "GET",
        url: `/order/auth/${page}/${limit}`,
      });
    // 2.获取当前用户的订单信息
    export const reqGetOrder = () =>
      request({
        method: "GET",
        url: `/order/auth/trade`,
      });
    // 3.提交订单
    export const reqSubmitOrder = ({
      tradeNo,
      consigneeTel,
      orderDetailList,
      orderComment,
      deliveryAddress,
      paymentWay,
      consigne,
    }) =>
      request({
        method: "POST",
        url: `/order/auth/submitOrder`,
        params: { tradeNo }, // query参数
        data: {
          consigne, // 收件人姓名
          consigneeTel, // 收件人电话
          deliveryAddress, // 收件地址
          paymentWay, // 支付方式 (ONLINE代表在线)
          orderComment, // 订单备注
          orderDetailList, // 存储多个商品对象的数组
        },
      });
    // 4.获取订单的支付信息
    export const reqGetPayInfo = (orderId) =>
      request({
        method: "GET",
        url: `/payment/weixin/createNative/${orderId}`, // 支付订单ID (通过提交订单得到)
      });
    // 5.查询的支付状态
    export const reqGetPayStatus = (orderId) =>
      request({
        method: "GET",
        url: `payment/weixin/queryPayStatus/${orderId}`, // 支付订单ID (通过提交订单得到)
      });
  }
  #